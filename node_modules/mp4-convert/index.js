var child_process = require('child_process');
var events = require('events');
var util = require('util');

var Mp4Convert = function(input, output) {
	this.input = input;
	this.output = output;
};
util.inherits(Mp4Convert, events.EventEmitter);


Mp4Convert.prototype.start = function() {
	var ffprobe = util.format('ffprobe -hide_banner -print_format json -show_format -show_streams "%s"', this.input);
	// When outputting to json, you have to opt in to each piece of info.
	this.emit('ffprobeCommand', ffprobe);
	child_process.exec(ffprobe, {maxBuffer : 2048 * 1024}, (function(error, stdout, stderr) {
		if (error !== null) {
			return this.emit('error', error);
		}
		this.ffprobeJson = JSON.parse(stdout);
		this.emit('ffprobeOutput', this.ffprobeJson);
		return this.ffmpeg();
	}).bind(this));	
}



Mp4Convert.prototype.ffmpeg = function() {
	var codecVideo = 'libx264';
	var codecAudio = 'aac';
	this.ffprobeJson.streams.forEach(function(stream) {
		if (stream['codec_type'] === 'video' && stream['codec_name'] === 'h264') {
			codecVideo = 'copy';
		}
		if (stream['codec_type'] === 'audio' && stream['codec_name'] === 'aac') {
			codecAudio = 'copy';
		}
	});
	this.emit('codecVideo', codecVideo);
	this.emit('codecAudio', codecAudio);
	
	this.duration = parseFloat(this.ffprobeJson.format.duration);
	this.emit('duration', this.duration);
	
	var args = [
		'-y',
		'-hide_banner',
		'-i',
		this.input,
		'-c:v',
		codecVideo,
		'-c:a',
		codecAudio,
		'-strict',
		'experimental',
		'-movflags',
		'faststart',
		this.output,
	];
	var child = child_process.spawn('ffmpeg', args);
	var that = this;
	
	child.stdout.on('data', function(data) {
		
	});
	child.stderr.on('data', function(data) {
		var duration = parseFfmpegOutput(data.toString());
		if (duration) {
			var progress = duration / that.duration;
			that.emit('progress', progress);
		}
	});
	
	child.on('error', function(err) {
		that.emit('error', err);
	});
	child.on('exit', function(code, signal) {
		if (code !== 0) {
			that.emit('error', 'Unsuccessful exit code '+code, signal);
			return;
		}
		that.emit('done');
	});
}



var sampleOutput = "frame=  262 fps=0.0 q=-1.0 size=   10334kB time=00:00:10.80 bitrate=7836.5kbits/s\n"
	+ "frame=  521 fps=520 q=-1.0 size=   14946kB time=00:00:21.60 bitrate=5666.7kbits/s";

function parseFfmpegOutput(data) {
	// Parse some output and return the duration corresponding to the first match,
	// or null if there's no match.
	var matches = data.match(/time=\d{2}:\d{2}:\d{2}/);
	if (!matches) {
		return null;
	}
	var match = matches[0];
	var hours   = parseInt(match.substr(5, 2));
	var minutes = parseInt(match.substr(8, 2));
	var seconds = parseInt(match.substr(11, 2));
	return hours*60*60 + minutes*60 + seconds;
}



module.exports = Mp4Convert;

